# 为什么要有告警？

告警是系统的“求救信号”。它让工程师不用 24 小时趴在监控面板上，而是当问题苗头出现时，能第一时间收到通知。常见的触发场景包括：

1. **系统故障**：比如节点宕机、容器漂移、心跳丢失等。
    
    告警可以立刻通知相关负责人，让他们比用户更早知道“出事了”。
    
2. **提前发现隐患**：
    
    比如 CPU 利用率长期 90%、Redis 内存逼近上限、接口延迟飙升但尚未崩溃。
    
    这些“亚健康信号”如果被及时关注，就能在事故发生前把风险扼杀在摇篮里。
    

一句话总结：**告警的价值，不在于发现问题，而在于让问题可控。**

# 告警机制

不同的监控系统实现方式各异，但万变不离其宗。大体可分为三种：

**1. 基于指标的告警**

最常见也最基础。

公式大概是：

> 统计值（如平均值、最大值、99分位等） > 阈值 → 持续一定时间 → 触发告警。
> 

这种方式简单粗暴、好理解。但如果阈值设置不合理，就会带来“告警雪崩”。

**2. 基于事件的告警**

事件型告警往往更具业务语义。比如：

- ECS 实例被意外删除；
- 数据同步任务失败；
- 服务自动重启超过 3 次。

这类告警更贴近“实际动作”，适合监控重要流程。

**3. 基于日志的告警**

当指标捕不到问题，而日志已经在尖叫。

例如：

- 日志中出现 “ERROR”、“Exception”、“500 Internal Server Error”；
- 支付系统出现 “支付失败且未回滚”。

很多团队会用 ELK、Loki、Datadog 等方案，从日志流中实时挖掘异常模式。

告警的机制可以分为基于阈值的告警、基于事件的告警和基于日志的告警。

# 告警配置的原则：少而精，准而狠

告警太多，就像一个满屋乱响的警报器——没人会再去认真听。

每当告警发生，值班同学就得中断手头的工作。误报多了，大家的反应速度就会像老旧 SSD 一样慢半拍。

要想让告警既“叫得响”，又“叫得值”，建议遵循以下三条：

1. **真实性**
    
    告警要反映真实存在的问题，而不是某个瞬时波动。比如 CPU 一秒冲到 90%，然后立刻降下来——那是虚惊一场，不该惊动全员。
    
2. **表述详细**
    
    一条好的告警不只是说“服务异常”，而是告诉你：“在 10:23:45，北京区 A 实例的 QPS 降低了 30%，延迟 P99 超过 2s。”
    
    这样开发同学一眼就能知道问题大致在哪。
    
3. **可操作性**
    
    收到告警后要知道该干啥。
    
    如果是那种“知道也没法做什么”的告警，比如某台测试机 CPU 突然飙高——那不如取消它。
    

**一句话总结：没有行动指向的告警，都是噪声。**

# 常见的告警问题

| 问题 | 优先级 |
| --- | --- |
| 预发与线上告警策略不一致，导致预发环境无法提前发现问题。 | P0 |
| 告警数量庞大且缺乏处理机制，大部分告警无人响应。 | P1 |
| 不同 region 告警配置不统一，重复工作量大、容易误配。 | P2 |

# 如何减少告警噪声

如果你每天都被 300 条告警短信轰炸，先别怪运维平台，可能问题出在你自己的监控策略上。

以下是一些行之有效的治理办法：

1. **精简监控项**
    
    只监控“值得担心”的指标。
    
    例如对请求量极低的接口没必要设置 P99 延迟告警。
    
2. **合理调整阈值**
    
    阈值过低，误报成灾；过高，又容易错过真实问题。
    
    可以用历史数据分析来确定分位值，甚至让系统根据最近 7 天数据自动微调阈值。
    
3. **定期清理**
    
    就像清理垃圾代码一样，告警规则也要定期复盘。
    
    哪些从没触发过、哪些经常误报，都该被“优化掉”。
    
4. **建立预警机制**
    
    不要等告警响了才行动。
    
    比如，当磁盘使用率持续上升趋势明显时，就该主动扩容，而不是等到 99% 再手忙脚乱。
    

### 实际案例

| 不合理的告警 | 解决方案 | 是否可用智能优化 | ROI |
| --- | --- | --- | --- |
| 慢 SQL 告警泛滥（DTS 插入耗时高） | 调整阈值：1s → 3s；或基于百分位自动生成阈值建议。 | ✅ 可用 ML 或统计建模优化 | 👍 高（减少 80% 噪声） |

> 一些成熟公司会用简单的分位统计或基线算法，让系统自动推荐告警阈值，这比人工调整高效多了。

# 告警分级：谁该被叫醒？😴

告警分级的目标很简单——**别让研发被无关紧要的告警吵醒。**

我们通常会把告警分为以下几个等级：

- **P0：** 业务核心中断，用户受影响，必须立刻响应（谁在睡觉都得被拉醒）。
- **P1：** 部分服务异常，但有降级路径。需在短时间内处理。
- **P2：** 非核心模块或性能告警，可在工作时间跟进。
- **P3：** 日志、趋势类问题，仅需定期复盘即可。

此外，通知方式也该分级：

P0 用电话、钉钉或 PagerDuty；

P1 可用短信或即时消息；

P2、P3 就发邮件或日报吧，别再打扰人类休息时间。
