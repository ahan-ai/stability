# 删除保护与软删除设计

删除，是一种看似简单但极具风险的操作。一句命令敲下去，可能一夜回到解放前。在云服务中，数据一旦被删除，将难以或无法被找回，所以，**删除操作需要保护机制！**

## 删除操作的防护原则

在设计系统时，我们应尽量减少误删带来的风险。可以参考以下实践：

- 【**必须**】**权限收敛与身份认证**
    
    删除操作应仅限特定角色执行，并记录“谁删除了什么”。这不仅是审计要求，也是问题追溯的关键。
    
- 【**推荐**】**软删除 / 回收站机制**
    
    数据不是立即物理删除，而是标记为“已删除”。这样即便用户一时手滑，还有机会挽回。
    
    有时候，“后悔药”真的是系统稳定性的救命稻草。
    
- 【**推荐**】**删除确认（Double Check）**
    
    删除前弹个框：“你确定要删？这可是生产数据哦⚠️”。
    
    —— 听起来傻，但每年都能救无数线上系统。
    
- 【**推荐**】**默认开启删除保护**
    
    默认情况下资源不可删，必须显式关闭“保护模式”后才能删除。
    
    类似“保险丝”，平时看着没用，关键时刻保你一命。
    

# 软删除机制（Soft Delete）

在数据库中，传统的删除操作（DELETE）会**彻底抹除数据**，从此“无迹可寻”。

但我们很多时候希望能“假删”一下，留个后路。

这时就轮到**软删除（Soft Delete）**上场了。✨

软删除的核心思想是：

> 不删除数据，只在逻辑上标记它“已被删除”。
> 

最常见的做法是在表结构中加入一个布尔字段：

```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  is_deleted BOOLEAN DEFAULT false
);
```

删除时，只需更新 `is_deleted = true`。

查询时，加上 `WHERE is_deleted = false`，就能轻松过滤掉“假删”的数据。

为了更好地追踪，还建议添加一个 `deleted_at` 字段记录删除时间：

```sql
ALTER TABLE users ADD COLUMN deleted_at TIMESTAMP NULL DEFAULT NULL;

```

> 🕐 “deleted_at” 就像给数据贴上了“死亡时间”，非常方便后期分析与恢复。
> 

---

## 软删除的数据清理策略

软删除并不是永远不删。

否则系统迟早会变成一个“垃圾堆”。

常见做法是：

为被软删除的数据设置一个“**过期时间**”，例如 **6 个月**。

为什么是 6 个月？

这其实是一个“合规兼容”的时间窗口。

参考《中华人民共和国网络安全法》的要求：网络日志和操作记录需**保留不少于六个月**。

因此，大部分系统会同步采用这一时长作为数据留存期。

在此基础上，可以配置一个后台任务（如定时任务或异步 worker）定期执行清理逻辑：

1. 清理过期的软删除数据；
2. 若数据量压力仍高，可分批继续清理旧数据。

这样，既能留有审计追溯窗口，又避免数据无限膨胀。

# 防误删保护设计

除了“删除逻辑”的保护，底层系统也需要防止**误操作导致的灾难性删除**。

例如某个管理员执行了：

```bash
rm -rf /opt/*

```

🤯 一不小心就能让整个服务“蒸发”。

于是我们可以引入“**防误删机制**”，用技术手段拦截这类危险操作。

## 技术方案对比

| 方案 | 简述 | 优点 | 缺点 |
| --- | --- | --- | --- |
| **方案一：chattr 加锁保护** | 通过 `chattr +i` 或 `+a` 属性防止文件删除 | • 内核自带，稳定可靠• 可精确到单文件或目录• 可防止 mv / rm 删除 | • 修改前需解除属性，操作繁琐• 不支持正则匹配• 不同系统兼容性不一 |
| **方案二：safe-rm 黑名单机制** | 用 `safe-rm` 替代系统 `rm` 命令，并维护防删目录黑名单 | • 可配置灵活，兼容性强• 可全局生效• 业务侵入小 | • 仅拦截 `rm` 命令，不防 `mv` 删除• 黑名单配置需维护• 存在潜在开源漏洞风险 |

出于运维便利和安全平衡，实际中多数系统会采用 **safe-rm 方案** 来防止误删关键目录。

# 方案设计思路

### 安装流程

1. 将 `safe-rm` 二进制安装到 `/usr/local/bin/` 并改名为 `rm`；
2. 修改 PATH 环境变量，使系统优先使用新命令；
3. 设置执行权限 `chmod +x /usr/local/bin/rm`。

### 升级与卸载

- 升级时，通过补丁或配置分发方式更新；
- 卸载时，删除 `/etc/safe-rm.conf` 配置文件即可恢复原始行为。

### 黑名单配置

safe-rm 支持多层级配置：

- `/etc/safe-rm.conf`：系统级保护目录（对所有用户生效）；
- `~/.config/safe-rm`：用户级保护目录（仅当前用户有效）。

示例配置：

```go
/usr
/opt
/opt/*
/data00/deploy
```

执行删除时，safe-rm 会先检查路径是否在黑名单中。

若匹配，则直接拒绝操作并输出提示，而不会真正执行 /bin/rm 。

## 原理简述

执行 `rm` 命令时，safe-rm 会：

1. 拦截命令；
2. 检查目标路径是否命中黑名单；
3. 若命中，则终止删除操作；
4. 若未命中，则正常调用系统的 `/bin/rm` 完成删除。

整个过程轻量、安全，对系统的性能影响极小。

# 推荐防护目录清单

| 路径 | 说明 |
| --- | --- |
| `/` | 系统根目录 |
| `/bin` | 系统命令目录 |
| `/usr` | 用户程序与共享资源 |
| `/etc` | 系统配置文件 |
| `/sys` | 虚拟文件系统（内核状态） |
| `/lib` | 动态链接库目录 |
| `/proc` | 系统运行状态接口 |
| `/boot` | 启动文件与镜像目录 |

> ✅ 建议：
> 
> - 对这些路径启用删除保护；
> - 业务自定义目录可通过配置声明，如：
>     
>     ```yaml
>     FolderOrFileProtection:
>        - "/opt"
>        - "/opt/*"
>     
>     ```
>     

# 总结

删除是“系统稳定性的大敌”，但防删的艺术在于**“防得住误操作，又不妨碍业务”**。

从策略层面（权限控制）、数据层面（软删除）到系统层面（safe-rm 防误删），

我们要建立起一条“多层防线”来抵御人为失误。