# 重试（Retry）

在分布式系统的世界里，失败是常态，而不是例外。网络会抽风，服务会超时，依赖会打瞌睡。于是，我们需要一种机制，让系统在遇到临时性问题时，不至于“一跤就趴下”。这就是——**重试（Retry）**。

## 什么是重试？

**重试机制**是一种自动化的故障恢复手段。当系统调用失败时（比如网络抖动、依赖服务短暂不可用），程序会在可控的范围内，自动再次发起同样的请求。通过有节制的“第二次机会”，系统能显著提升**可用性（Availability）与稳定性（Stability）**。

简单说，重试是让系统变得更“乐观”的一种策略：

> “我不信你真的挂了，我再试一次。”
> 

## 为什么需要重试？

在分布式环境下，**短暂性错误（Transient Error）**非常常见，比如：

- 🔄 网络抖动导致请求超时；
- 💾 数据库连接池被瞬间打满；
- 🌐 第三方 API 返回 `504 Gateway Timeout`；
- ☁️ 服务实例刚好在重启，或者在发布中。

这些问题往往在几百毫秒或几秒后就会恢复。如果应用没有重试机制，那么一次临时错误可能导致整条链路失败，用户就会看到“服务不可用”的提示——这在高并发场景下尤其危险。而通过合理的重试，系统就能从“小故障”中自我恢复，不必惊慌。

## 重试的关键设计点

### 1. 限制重试次数

不要盲目地一条路走到黑。如果某个操作失败了十几次，它大概率不是暂时性问题，而是真挂了。

> 建议：限制最大重试次数（如 3～5 次），并在失败后及时告警或降级。
但同时也要注意，如果重试停止，是否会导致留下一些难以处理和回收的垃圾资源。
> 

### 2. 延迟与退避策略

直接疯狂重试只会火上浇油，最终使下游服务雪崩（我们将在其它章节讨论流量控制）。常用的退避算法包括：

- **固定间隔（Fixed Delay）**：每次重试间隔固定，比如每 2 秒一次；
- **指数回退（Exponential Backoff）**：每次重试间隔成倍增长，如 1s → 2s → 4s（但也最好设置一个最大上限）；
- **随机抖动（Jitter）**：在间隔时间上添加随机性，防止“群体雪崩”。

💡 一条经验法则：

> 如果你需要重试 3 次以上，请确保退避策略是动态的。
> 

### 3. 区分可重试与不可重试错误

并非所有错误都值得重试。有些错误是“逻辑错误”，比如参数非法、权限不足、业务规则冲突，这类问题无论你试多少次都不会变好。真正适合重试的是那些**临时性失败（transient failure）**，比如网络抖动或资源短缺。

> 建议：定义清晰的可重试错误类型（如 HTTP 5xx、超时类异常）。
> 

### 4. 重试与幂等性配合

重试和幂等性通常需要一同考虑。如果接口不是幂等的，重试可能会造成**重复执行**或**状态污染**。例如：

- 用户点击“创建资源”按钮；
- 第一次请求超时（其实服务端已创建成功）；
- 系统自动重试；
- 于是资源被创建了两次（甚至多次）。

结果：系统崩溃，用户困惑。

> 因此，每一个被重试的接口，都必须保证幂等性。否则，重试机制就成了“灾难放大器”。
> 

## 实际案例（行业通用）

假设一个支付服务在调用银行接口时偶发超时。

**错误做法：**

```go
// 坏例子：无脑重试
for i := 0; i < 10; i++ {
    resp, err := BankAPI.Transfer(...)
    if err == nil {
        return resp
    }
}
```

结果：用户被扣款 10 次。

**正确做法：**

```go
// 好例子：限制次数 + 退避策略 + 可重试判断
for i := 0; i < 3; i++ {
    resp, err := BankAPI.Transfer(...)
    if err == nil {
        return resp
    }

    if !IsTransientError(err) {
        break // 不可重试错误，直接返回
    }

    delay := time.Duration(math.Pow(2, float64(i))) * time.Second
    time.Sleep(delay)
}
```

这段代码只重试三次，每次间隔递增，并判断错误类型是否适合重试。安全、可控、优雅。

## Golang 实现示例（基于 retry-go 库）

### 基本用法

```go
package main

import (
    "errors"
    "fmt"
    "github.com/avast/retry-go/v4"
)

func main() {
    err := retry.Do(func() error {
        fmt.Println("Trying...")
        return errors.New("temporary error")
    })
    if err != nil {
        fmt.Printf("Final error: %v\n", err)
    }
}

```

> 🧩 retry.Do 会重复执行提供的函数，直到成功或达到最大重试次数（默认 10 次）。
> 

---

### 自定义重试策略

```go
err := retry.Do(
    func() error {
        return errors.New("an error occurred")
    },
    retry.Attempts(5),                  // 重试 5 次
    retry.Delay(2 * time.Second),       // 每次间隔 2 秒
    retry.DelayType(retry.FixedDelay),  // 固定延迟模式
)

```

---

### 条件重试

```go
err := retry.Do(
    func() error {
        return errors.New("non-retriable error")
    },
    retry.RetryIf(func(err error) bool {
        // 仅在“临时错误”时重试
        return err.Error() == "temporary error"
    }),
)
```

### 指数回退策略

```go
err := retry.Do(
    func() error {
        return errors.New("temporary failure")
    },
    retry.DelayType(retry.BackOffDelay), // 指数退避模式
)
```

---

### 上下文控制（防止无限等待）

```go
ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
defer cancel()

err := retry.Do(
    func() error {
        return errors.New("operation failed")
    },
    retry.Context(ctx), // 超时自动取消
)
```

### 自定义日志钩子

```go
err := retry.Do(
    func() error {
        return errors.New("error example")
    },
    retry.OnRetry(func(n uint, err error) {
        fmt.Printf("Attempt %d failed: %v\n", n+1, err)
    }),
)

```

### 混合配置示例

```go
err := retry.Do(
    func() error {
        return errors.New("example error")
    },
    retry.Attempts(3),
    retry.Delay(1*time.Second),
    retry.MaxJitter(500*time.Millisecond), // 添加抖动防止雪崩
)
```

## 工程实践建议

💡 以下是重试机制落地的实战经验：

- **搭配幂等性使用**：重试前确认接口可安全重复调用；
- **监控重试率与成功率**：高重试率往往是潜在问题的信号；
- **避免“雪崩”重试**：所有客户端同时重试会造成“第二次洪峰”；
- **记录失败上下文**：方便后续分析是否属于可恢复错误；
- **使用统一的 Retry 模块**：避免不同服务各自实现不同逻辑。

## 总结

重试机制，就像系统的“自愈能力”一样——当一次小意外发生时，它能让服务稳住阵脚，不轻易倒下。但如果使用不当，它也可能成为“放大错误的倍增器”。

> ✅ 合理设计的重试机制：
> 
> - 能在临时性故障中快速恢复；
> - 避免因瞬时抖动造成用户可见错误；
> - 减轻运维干预负担。

> ❌ 不合理的重试机制：
> 
> - 会导致请求风暴和系统崩溃；
> - 在非幂等操作中引发重复执行和脏数据。

# 幂等性设计（Idempotency Design）

在分布式系统中，一个请求是否被执行多次，往往取决于网络延迟、重试机制、消息重复发送、甚至是用户的“多次点击”。而幂等性设计，就是为了应对这些不确定性。简单来说：**同一个操作，无论执行一次还是多次，最终结果都应该一致**。

这个特性在保证系统稳定性时尤其关键。因为在复杂的调用链中，请求可能在任意一个环节被“多投一票”，而幂等性让系统能够从容面对这些重复请求，而不会引起数据错乱或状态异常。

## 为什么需要幂等性

我们来设想一个经典场景：

用户在支付页面点击“提交”后，由于网络卡顿，浏览器没有及时响应，用户又点了一次。

如果后台没有幂等性设计—— 恭喜你，用户可能付了两次钱。

而在一个分布式系统中，这种“重复触发”的问题并不止发生在用户界面上。

例如：

- **重试机制**：客户端或中间层发现请求超时，会自动重试。
- **消息队列**：消费者可能在未确认 ACK 前崩溃，导致消息被重新投递。
- **下游服务超时**：上游认为失败而重发，但实际上下游已经成功处理。

这些情况在分布式环境中非常普遍，如果系统没有幂等保护，这些重试都会带来严重后果。

典型风险包括：

- **资源重复创建**：例如用户重复点击“创建云主机”，可能产生多台实例；
- **数据不一致**：同一请求被执行两次导致状态错乱；
- **重复扣款或消息投递**：支付系统或消息系统中极易出现此类问题。

因此，幂等不仅仅是 API 的特性，而是一种**系统稳定性保障机制**。

## 常见的幂等性实现方式

### 1. 唯一请求 ID（Request ID）

最通用的做法是由**请求的发起者**，为请求分配一个全局唯一的 ID。服务端在处理请求前，先判断该 ID 是否已存在于幂等记录表中：

```python
def process_request(request_id, payload):
    if is_processed(request_id):
        return "duplicate_request"

    result = do_business_logic(payload)
    mark_as_processed(request_id)
    return result
```

这类方案的优点是**通用、易于理解**，但需要考虑存储幂等记录的开销和过期策略。

### 2. 幂等操作的业务语义化

有些业务天生就具有幂等性，例如：

- 查询类接口（GET）；
- 删除操作（DELETE /user/123）；
- 更新固定值的接口（PUT /user/123/status=active）。

设计 API 时尽量**让操作语义天然幂等**，能从根本上减少复杂度。

例如：

相比于“给账户充值 100 元”，

“将账户余额更新为 X 元”就是一个幂等操作。

### 3. 幂等状态机

对于复杂操作，可以设计一个简单的状态流转机制：每个操作都必须遵循状态机规则进行更新。

例如订单状态：`CREATED -> PAYING -> PAID -> SHIPPED`

如果请求重复到达，系统发现当前状态已经是目标状态，就不再重复执行。

这种设计在**高并发、高一致性要求的业务场景**中非常实用。

## 幂等性陷阱与注意事项

1. **误以为重试一定安全**：
    
    如果幂等逻辑仅在单节点缓存中，而请求路由到其他节点，就会再次执行。
    
    → 建议使用**分布式幂等记录**（如 Redis、数据库等）。
    
2. **记录清理问题**：
    
    幂等记录如果不清理，会导致存储无限增长；
    
    如果清理太快，又可能在重试期间失效。
    
    → 可通过 TTL（过期时间）和幂等窗口（例如 10 分钟）平衡。
    
3. **分布式事务干扰**：
    
    如果操作跨多个系统，需要考虑幂等性的一致性传播，否则仍可能导致“局部重复执行”。
    
4. **接口粒度设计不合理**：
    
    如果接口本身定义得太细（如“追加日志”），可能天然不幂等，建议通过**更高层的封装**来保证幂等性。
    

## 工程实践示例

在大型系统中（如电商、金融、云平台等），幂等性几乎是“标配”。

例如：

- 订单支付接口通过支付流水号 + 用户 ID 作为幂等键；
- 云 API 的资源创建接口要求提供 `ClientToken`；
- 消息队列消费者在执行完任务后，写入消费日志，避免重复消费。

这些实践的核心目标都是：**即使请求重复到来，系统的最终状态仍然正确。**

### ClientToken：API 幂等保障机制

在云服务与大型分布式系统中，**ClientToken** 是一种通用的幂等保障机制。

它的核心思想是：

> 同一请求的唯一标识决定操作的唯一性。
> 

客户端在请求时带上 `ClientToken` 参数，服务端在收到请求后：

1. 查询该 Token 是否已处理；
2. 若已处理，则直接返回之前的结果；
3. 若未处理，则执行逻辑并缓存结果。

ClientToken 的特性

- **唯一性**：每次生成唯一标识，可基于 UUID、随机数或时间戳。
- **作用域限制**：ClientToken 仅在特定操作（如“创建实例”）中有效。
- **结果复用**：相同 Token 的重复请求，返回第一次执行结果。

典型场景

- **云资源创建**：如创建虚拟机、存储卷、负载均衡实例等操作。即使因为超时重试，服务端也只会创建一个资源。
- **支付系统**：确保同一交易请求不会被重复执行，防止重复扣费。
- **消息投递**：确保消息只被消费一次（At-Most-Once / Exactly-Once 模型）。

使用注意事项

- **Token 过期策略**：为避免状态表无限增长，幂等键应有 TTL（如 24 小时）；
- **安全性**：Token 不应可预测，防止被恶意重放；
- **幂等结果缓存**：结果需与 Token 绑定，存储在高速可访问系统（如 Redis、KVStore）中。

## 小结

幂等性设计是分布式系统的“防抖机制”。它并不能阻止重复请求的发生，但能确保结果的稳定一致。在工程实现上，它往往是“重试机制”的天然搭档——前者负责兜底，后者负责纠错。