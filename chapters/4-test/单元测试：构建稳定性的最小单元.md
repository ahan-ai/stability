# 单元测试

> “测试不是为了证明代码没问题，而是为了发现它到底有多脆。”
> 

很多人对“单元测试”的第一印象是：**“测试函数的嘛！”**

这话没错，但也不完全对。函数确实是单元测试最常见的对象，但“单元”并不局限于函数。

根据维基百科的定义：

> In computer programming, unit testing is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use.
> 

简单来说，单元测试关注的是**源代码中最小可验证的逻辑单元**。

在过程式编程中，这个“单元”通常是函数或过程；

在面向对象编程中，它可能是一个类、接口，甚至是一个方法。

换句话说，单元测试不是“测函数”，而是**验证一个独立逻辑的可靠性**。

它是“代码自信的来源”——让我们在修改代码时不用祈祷一切正常，而是靠一键运行测试告诉自己：

> “放心改，炸不了。” 💣
> 

当然，单元测试的目标也不只是验证输入输出是否匹配，更重要的是：

- 快速捕捉逻辑错误
- 让重构更有安全感
- 降低回归测试成本
- 让新同事敢动旧代码（这是最重要的 😎）

# Mock / Stub / Fake：测试的“假依赖”

## Stub（桩）

在测试中，我们常常不想依赖某个复杂、外部或不可控的组件——比如数据库、网络服务或时间。

这时就需要 **Stub**。

> A stub is a controllable replacement for an existing dependency in the system.
> 

简单说，Stub 就是**把真实依赖换成可控的假货**。

它的目标是：**让测试更快、更稳定、可重复。**

举个例子：

你要测试函数 `A()`，但它依赖外部服务 `B()`。

为了避免等待网络请求或遭遇偶发错误，你写了一个假的 `B()`，始终返回成功。

于是 `A()` 就能顺利执行流程，而不会被外部条件阻断。

```go
// 将函数定义为变量形式，而不是普通函数
var GetDataFromService = func() string {
	return "real-data"
}

func ProcessData() string {
	data := GetDataFromService()
	return "processed-" + data
}

// 测试中使用 Stub 替换真实依赖
func TestProcessData(t *testing.T) {
	original := GetDataFromService
	defer func() { GetDataFromService = original }() // 恢复
	GetDataFromService = func() string { return "stub-data" }

	got := ProcessData()
	want := "processed-stub-data"
	if got != want {
		t.Errorf("got %v, want %v", got, want)
	}
}
```

在这里，我们用 stub 替换了真实依赖，验证了核心逻辑是否正确。

## Mock

Mock 与 Stub 相似，但它更强调**验证调用行为**。

比如 Mock 会记录函数被调用的次数、参数、顺序等，用于断言“是否按预期交互”。

Mock 更偏向于**行为验证**（Behavior Verification），而 Stub 偏向于**状态验证**（State Verification）。

Go 语言中可以使用 [bytedance/mockey](https://github.com/bytedance/mockey) 来快速打桩或 mock 函数。

它通过运行时指令替换实现“猴子补丁（Monkey Patch）”，在单测中非常方便。

部分专业的书籍，会尝试给 stub 和 mock 不同的定义，不过在实际项目中，很多人也懒得区分这俩——只要能跑通测试，谁管你叫啥呢😂。

## Fake

Fake 是另一种“假对象”，但它比 Stub 和 Mock 更像一个**简化版的真实实现**。

> A Fake Object implements the same functionality as the real component, but in a much simpler way.
> 

典型例子是：用一个**内存数据库**替代真实数据库，支持 CRUD 但不落盘。

Fake 适合需要真实行为但不希望外部依赖的场景。

```go
type InMemoryDB struct {
    store map[string]string
}

func (db *InMemoryDB) Save(key, val string) {
    db.store[key] = val
}
func (db *InMemoryDB) Get(key string) string {
    return db.store[key]
}
```

# Golang 中的单元测试实用技巧

## 运行目录下所有测试

```bash
go test ./...

```

## 运行指定测试文件或用例

```bash
go test -v ./pkg/election -run TestLog

```

## 查看覆盖率报告

```bash
go test -coverprofile=c.out ./pkg/election
go tool cover -html=c.out -o=coverage.html

```

## 常用参数

- `failfast`：某测试失败后立即停止
- `count=1`：禁用缓存，强制重新运行测试
- `race`：检测数据竞争

## Golang 常用测试工具

| 工具 | 功能 | 特点 |
| --- | --- | --- |
| **gotestsum** | 增强版 go test | 彩色输出、失败重跑、JUnit 报告 |
| **mockey** | 打桩 / mock 工具 | 运行时函数替换（Monkey Patch） |
| **GoConvey** | BDD 风格测试框架 | 实时运行测试、可视化报告 |

使用 mockey 时需加上 `-gcflags="all=-N -l"`，否则可能得到意外结果。

## 测试框架与代码结构建议

1. 对第三方函数调用加封一层，便于替换。
2. 优先依赖接口而非具体实现，以便注入 Fake。
3. 使用 `var fn = realFn` 的方式声明函数，可通过 GoStub 替换。
4. 各模块通过接口调用，以便在测试中注入 mock 实现。

# 工程实践：从单元测试到稳定性保障

在一些实际工程实践中，当研发提交代码（Pull Request）时，CI 平台会自动运行对应 UT，并生成报告，包括：

- 新增代码的覆盖率（通常要求 ≥ 75–85%）
- 改动文件的详细覆盖行信息
- 并在覆盖率不达标时阻断合并

这让测试成为开发流程的“第一道防线”，也为后续的**集成测试、混沌演练、稳定性验证**打下基础。

单元测试不仅验证功能，更是稳定性的起点。它让我们能在小范围内快速发现缺陷、建立信任，进而扩展到系统级的稳定性验证。