最重要的原则，升级应做到兼容。想象一下你的 iPhone，如果升级版本后，一大堆的App 都打不开了，是不是一个灾难性的事故。原则是：变更（发布、升级）不会导致现有的调用出现异常。

我们的服务通常会把一部分数据，存储在各种各样的系统里，比如MySQL、Etcd、文件系统等等。随着业务的发展，数据格式可能会发生变化，比如MySQL的表格里增加了一列，比如存储的C数据结构变化了等等。

这些改动，有些是可以向前兼容的，有些则是会影响升级和兼容性的。在做设计评审或者开发的时候，同样需要考虑平滑升级以及兼容性。

## API 兼容性

本文的API，泛指各种类型的接口，包括HTTP API、库函数、thrift、脚本参数等等，只要涉及到A通过某种约定好的『协议』调用B，那么这个『协议』就算是API。

所以API是双方的一种约定，既然是约定，那么原则上不允许随意变动，否则会对调用方产生意想不到的影响。本文针对不同的API协议，给出我们建（qiang）议（zhi）的实践方式。

### Thrift

Thrift协议是目前广泛使用的一种跨语言二进制协议，在团队内部也广泛用于定义API。一旦使用Thrift定义好通信的接口（比如requst、response）后，那么接口一旦发布，原则上不允许随意进行更改。

以下的更改都是禁止的：

- 删除、更改API（名称）。
- 删除、更改请求中原有的参数。
- 请求参数增加必选字段。
- 将可选的请求参数修改为必选参数。
- ...

以上的更改仅在100%保证在线平滑升级及兼容性的情况下才被允许。例如是API还未发布，或者存量的系统里旧API已经没有任何调用方存在。

如果现有的API要更改，原则上仅允许：

- 添加一个可选参数，并且请求双方必须可以正确处理参数没有赋值的情况。

### HTTP API

云服务的OpenAPI通常体现为HTTP API。OpenAPI原则上必须保证向前兼容，因为我们无法评估某个已发布的API是否已经有用户在使用。

以下的更改是禁止的：

- 更改、删除OpenAPI。
- 更改、删除OpenAPI参数。
- OpenAPI增加必选参数。
- 修改OpenAPI原有的可选参数为必选参数。

如果出于各种原因，必须要删除已经发布的OpenAPI，原则上我们需要在官网给出相关的变更通知。我们强烈不推荐这种行为。

已经发布的OpenAPI，如果需要修改，那么推荐的做法是：

1. 旧API保持不变，创建新的API来满足新的需求，或者
2. 创建同名API，但是version不一样。

如果必须要改动原有的API，仅允许：

- 添加可选字段。

InnerAPI和OpsAPI的改动也同样遵循OpenAPI的规范。

### Library

以下更改是禁止的：

- 修改对外的API名称，包括但不限于模块名、包名、函数名、类名等等。
- 修改对外API的参数类型、参数个数、返回值类型等等。
- 改变函数的行为，约定好的语义。

## 数据兼容性

### 数据库MySQL

原则上禁止以下的改动：

- 删除数据库、表。
- 修改表名称。
- 删除表字段。
- 修改表字段名称、类型。

### 数据结构

数据结构的变更同样也可能会带来兼容性问题，而且一旦由于数据结构变更造成了无法升级或者其它兼容性问题，后续的补救措施成本会非常高。

其中，我们尤其需要关注的是那些存储（固化）到磁盘的数据结构，例如我们要在磁盘里保存的元数据，数据结构如下：

`struct meta_data {
   int32_t version;
   int64_t len;
   int32_t data1;
   int32_t data2;
}`

假设我们的元数据服务会把meta_data存储到磁盘的文件中，以数组的形式挨个存储。过一段时间后，元数据服务升级了，并且在meta_data中加入了新的字段：

`struct meta_data {
   int32_t version;
   int64_t len;
   int32_t data1;
   int32_t data2;
   int32_t data3;
}`

元数据服务升级后，无法识别原本存储在文件中的元数据了，因为元数据的长度发生了变化，如果用新的数据结构去解析旧的元数据文件，那么解析必然是失败的，或者解析到了意想不到的元数据，因此整个升级实际上是无法进行的。更严重的，如果解析通过了，但是由于解析到了错误的元数据，可能直接导致升级后的数据丢失。

为了避免上面的问题，我们推荐的做法是对于需要存盘的数据结构，预留一定的空间，便于后续扩展。例如：

`struct meta_data {
   int32_t version;
   int64_t len;
   int32_t data1;
   int32_t data2;
   int32_t pad1; // 后面的字段都是预留的
   int32_t pad2;
   int32_t pad3;
   u8_t    pad_byte[256];
}`

### Etcd/ZooKeeper

对于把数据存储在Etcd、ZooKeeper这一类的系统的服务来说，升级时，同样需要考虑数据格式的兼容性。

### 枚举值

枚举值是一种典型的数据类型，在研发的过程中，我们经常会添加各种枚举值，比如错误码。对于数值类型的枚举值，在研发的过程中，我们需要注意的是，新增的枚举值，一定要往后添加，而不可以添加到已有的枚举值的中间，即新增枚举值，不要改变原先的枚举值的含义。

另外不推荐在 IDL 里使用枚举值，因为如果一方更新了 IDL，添加了一个新的枚举量，而另外一方（解析）没有更新 IDL，则无法解析新的枚举值，造成不兼容的问题。